<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20120212145301.1344"><vh>@chapters</vh></v>
<v t="ntallen.20120212145301.1343" a="E"><vh>Time of Flight Instrument</vh>
<v t="ntallen.20120325104334.1395" a="E"><vh>Initial Notes</vh>
<v t="ntallen.20120212145301.1345"><vh>Timeline</vh>
<v t="ntallen.20120212145301.1347"><vh>Mid March: Custom A/D Boards</vh></v>
<v t="ntallen.20120212145301.1346"><vh>April 11-May 3: Integration</vh></v>
<v t="ntallen.20120212145301.1386"><vh>May 8: Transit to Salina Kansas</vh></v>
<v t="ntallen.20120212145301.1388"><vh>Jun 30: DC8 Transit to PMD</vh></v>
<v t="ntallen.20120212145301.1387"><vh>Aug 1: Transit to Thailand</vh></v>
<v t="ntallen.20120212145301.1389"><vh>Aug 8: Science Operations Begin</vh></v>
<v t="ntallen.20120212145301.1390"><vh>Sep 29: ER-2, DC-8 Transit PMD</vh></v>
</v>
<v t="ntallen.20120212145301.1348"><vh>Instrument History</vh>
<v t="ntallen.20120212145301.1349"><vh>Time of Flight</vh></v>
<v t="ntallen.20120212145301.1350"><vh>CIMS </vh>
<v t="ntallen.20120212145301.1377"><vh>Turbo Pumps</vh></v>
<v t="ntallen.20120212145301.1378"><vh>Iris Control</vh></v>
<v t="ntallen.20120212145301.1385"><vh>Inlet Control</vh></v>
<v t="ntallen.20120212145301.1379"><vh>Mass Selection</vh></v>
</v>
<v t="ntallen.20120212145301.1375"><vh>Triple</vh>
<v t="ntallen.20120212145301.1376"><vh>Specd/specq</vh></v>
<v t="ntallen.20120212145301.1356"><vh>Zaber</vh></v>
<v t="ntallen.20120215204101.1327"><vh>OMS</vh></v>
</v>
</v>
<v t="ntallen.20120212145301.1357"><vh>Questions</vh></v>
<v t="ntallen.20120212145301.1358" a="E"><vh>Command/Data Interconnect</vh>
<v t="ntallen.20120212145301.1359"><vh>Windows/ToF</vh>
<v t="ntallen.20120212145301.1360"><vh>Ethernet</vh></v>
<v t="ntallen.20120212145301.1361"><vh>ToF</vh></v>
</v>
<v t="ntallen.20120212145301.1383"><vh>Windows/Triple</vh>
<v t="ntallen.20120212145301.1384"><vh>specd</vh></v>
</v>
<v t="ntallen.20120212145301.1362" a="E"><vh>Hercules: QNX computer/power supply</vh>
<v t="ntallen.20120212145301.1363"><vh>Herc I/O</vh></v>
<v t="ntallen.20120212145301.1364"><vh>DMM32</vh></v>
<v t="ntallen.20120212145301.1365"><vh>OMS</vh></v>
<v t="ntallen.20120212145301.1366"><vh>ICATS: RS-232?</vh></v>
<v t="ntallen.20120212145301.1367"><vh>Zaber: RS-232?</vh></v>
<v t="ntallen.20120212145301.1368"><vh>RS-485 Ion Gauges</vh>
<v t="ntallen.20120215204101.1336"><vh>RS-485 Ion Gauge</vh>
<v t="ntallen.20120220091857.1356"><vh>Implementation</vh></v>
<v t="ntallen.20120220091857.1357"><vh>Testing</vh></v>
<v t="ntallen.20120220091857.1355"><vh>Questions</vh></v>
</v>
</v>
<v t="ntallen.20120212145301.1374"><vh>RS-232 Serial/I2C</vh></v>
<v t="ntallen.20120212145301.1382"><vh>specd/specq for Varian</vh></v>
<v t="ntallen.20120212145301.1373"><vh>Ethernet</vh>
<v t="ntallen.20120212145301.1371"><vh>QNet</vh></v>
<v t="ntallen.20120212145301.1372"><vh>TCP/IP</vh></v>
</v>
<v t="ntallen.20130628202556.1415" a="E"><vh>RS-485 MODBUS Watlow Interfaces</vh>
<v t="ntallen.20130628202556.1416"><vh>PM6C</vh></v>
</v>
</v>
<v t="ntallen.20120212145301.1369"><vh>AthenaII: Gas Box</vh>
<v t="ntallen.20120212145301.1370"><vh>A/D, D/A, DIO</vh></v>
<v t="ntallen.20120212145301.1380"><vh>DMM32</vh></v>
<v t="ntallen.20120212145301.1381"><vh>RS-485 Flow Controllers</vh>
<v t="ntallen.20120215204101.1337"><vh>RS-485 Flow Controller</vh></v>
<v t="ntallen.20120410211453.1407"><vh>Horiba Implementation</vh></v>
<v t="ntallen.20120412210238.1409"><vh>Resolution</vh></v>
<v t="ntallen.20120412210238.1410"><vh>Implementation</vh>
<v t="ntallen.20120415090314.1413"><vh>Queries</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ntallen.20120325104334.1393"><vh>Configuration</vh>
<v t="ntallen.20120325104334.1394"><vh>IP</vh></v>
</v>
<v t="ntallen.20120215204101.1328"><vh>Tasks</vh>
<v t="ntallen.20120215204101.1336"></v>
<v t="ntallen.20120215204101.1339"><vh>Diamond Systems Acquisition</vh>
<v t="ntallen.20120215204101.1340"><vh>API</vh></v>
<v t="ntallen.20120301085305.1369"><vh>Architecture</vh>
<v t="ntallen.20120301085305.1377"><vh>API</vh></v>
<v t="ntallen.20120301085305.1375"><vh>_IO_MSG</vh>
<v t="ntallen.20120301085305.1374"><vh>Multi-Write</vh></v>
<v t="ntallen.20120301085305.1371"><vh>Write</vh></v>
<v t="ntallen.20120301085305.1373"><vh>Multi-Read</vh></v>
<v t="ntallen.20120301085305.1372"><vh>Read</vh></v>
</v>
<v t="ntallen.20120301085305.1370"><vh>Quit/ASCII Interface</vh></v>
<v t="ntallen.20120301085305.1376"><vh>Address Space</vh>
<v t="ntallen.20120304143951.1387"><vh>A/D Strategy</vh>
<v t="ntallen.20120307100756.1389"><vh>Hercules</vh></v>
<v t="ntallen.20120307100756.1390"><vh>AthenaII</vh></v>
</v>
</v>
</v>
<v t="ntallen.20120215204101.1332"><vh>Hercules/AthenaII/DMM32 driver</vh>
<v t="ntallen.20120328210636.1402"><vh>AthenaII</vh></v>
<v t="ntallen.20120328210636.1401"><vh>Hercules</vh>
<v t="ntallen.20120328210636.1403"><vh>Specs</vh></v>
<v t="ntallen.20120331125541.1405"><vh>Address Space</vh></v>
</v>
</v>
<v t="ntallen.20120229211436.1363"><vh>Athena Signals</vh></v>
<v t="ntallen.20120229211436.1364"><vh>Hercules Signals</vh></v>
<v t="ntallen.20120229211436.1365"><vh>DMM32 Signals</vh></v>
</v>
<v t="ntallen.20120220091857.1358"><vh>Multi-node acquisition</vh>
<v t="ntallen.20120325104334.1396"><vh>todo: AthenaII</vh></v>
</v>
<v t="ntallen.20120215204101.1337"></v>
<v t="ntallen.20120215204101.1329"><vh>List of commands and data</vh></v>
<v t="ntallen.20120215204101.1330"><vh>Interconnect diagram</vh></v>
<v t="ntallen.20120215204101.1331"><vh>Port specq</vh></v>
<v t="ntallen.20120215204101.1335"><vh>Zaber</vh></v>
<v t="ntallen.20120215204101.1338"><vh>TCP/IP command/data</vh>
<v t="ntallen.20120212145301.1360"></v>
</v>
<v t="ntallen.20120215204101.1334"><vh>ICATS</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20120212145301.1343">@nocolor</t>
<t tx="ntallen.20120212145301.1344"></t>
<t tx="ntallen.20120212145301.1345"></t>
<t tx="ntallen.20120212145301.1346"></t>
<t tx="ntallen.20120212145301.1347"></t>
<t tx="ntallen.20120212145301.1348">DC-8
</t>
<t tx="ntallen.20120212145301.1349">Run under Windows using Matlab interface
What does it actually do and measure?</t>
<t tx="ntallen.20120212145301.1350"></t>
<t tx="ntallen.20120212145301.1356">Apparently controls the pinhole opening.</t>
<t tx="ntallen.20120212145301.1357">Review what the instrument is and how it works
  What does the Zaber control?
  OMS controls the IRIS, right? Just one axis?
  Is the Varian specq/specd required, or is ToF a replacement for this?
  What data is collected where?
  
  Shall we continue to use forge server for repository? Yes</t>
<t tx="ntallen.20120212145301.1358"></t>
<t tx="ntallen.20120212145301.1359"></t>
<t tx="ntallen.20120212145301.1360">For communication between ToF windows computer and Hercules
  Need to define:
      data requirements
      data format
</t>
<t tx="ntallen.20120212145301.1361">Data stored in HDF files. Will be controlled from Matlab
</t>
<t tx="ntallen.20120212145301.1362">herc_a: 131.215.103.182 as of 2/9/12
</t>
<t tx="ntallen.20120212145301.1363"></t>
<t tx="ntallen.20120212145301.1364"></t>
<t tx="ntallen.20120212145301.1365">Controls the inlet, closed loop for pressure control.
</t>
<t tx="ntallen.20120212145301.1366">This interface is documented in CIMS
</t>
<t tx="ntallen.20120212145301.1367">Using data channel #2 for Iris control. Not closed loop.
This interface is documented in Triple
</t>
<t tx="ntallen.20120212145301.1368">Probably just ion gauges. Handle flow controllers and pressure controller
via AthenaII interfaces. Could run the driver from Hercules or AthenaII
</t>
<t tx="ntallen.20120212145301.1369">athenaII_a: ip: 131.215.103.167
 RS485 ion gauge (MKS 972 DualMag) attached to /dev/ser4, and
 RS485 STEC MFC attached to /dev/ser3
 (I don't believe these are the final connections...)</t>
<t tx="ntallen.20120212145301.1370"></t>
<t tx="ntallen.20120212145301.1371">Interface to AthenaII
</t>
<t tx="ntallen.20120212145301.1372">Communication with Windows</t>
<t tx="ntallen.20120212145301.1373"></t>
<t tx="ntallen.20120212145301.1374">Custom A/D Board

SC18IM700

Need specs on what we need to collect/control and when
</t>
<t tx="ntallen.20120212145301.1375"></t>
<t tx="ntallen.20120212145301.1376">Communication with Varian mass spec running on Windows</t>
<t tx="ntallen.20120212145301.1377"></t>
<t tx="ntallen.20120212145301.1378">By Zaber?
</t>
<t tx="ntallen.20120212145301.1379">No longer required, since ToF measures all masses simultaneously
</t>
<t tx="ntallen.20120212145301.1380">Flow controllers (RS-485)
Analog control points for spare controllers
Analog pressure gauge reads
Solenoids controlled from DIO
</t>
<t tx="ntallen.20120212145301.1381">Flow controllers hooked up now
pressure controller using the same command scheme

Horiba Dak Japanese

Read works OK. If the error check bits doesn't match up, the response is unexpected.
</t>
<t tx="ntallen.20120212145301.1382">Same as with Triple
</t>
<t tx="ntallen.20120212145301.1383"></t>
<t tx="ntallen.20120212145301.1384">Same as it ever was.</t>
<t tx="ntallen.20120212145301.1385">via OMS</t>
<t tx="ntallen.20120212145301.1386"></t>
<t tx="ntallen.20120212145301.1387"></t>
<t tx="ntallen.20120212145301.1388"></t>
<t tx="ntallen.20120212145301.1389"></t>
<t tx="ntallen.20120212145301.1390"></t>
<t tx="ntallen.20120215204101.1327">For closed loop pressure control of the inlet.</t>
<t tx="ntallen.20120215204101.1328"></t>
<t tx="ntallen.20120215204101.1329"></t>
<t tx="ntallen.20120215204101.1330"></t>
<t tx="ntallen.20120215204101.1331">specq has to do the following:
    Accept commands
    Report status to telemetry
    Talk to specd via a socket
I think this could be rewritten using my select architecture.
</t>
<t tx="ntallen.20120215204101.1332">Check to make sure the two are roughly compatible.
Not really, but a lot of the framework can stay the same.
</t>
<t tx="ntallen.20120215204101.1334">This should be a very simple port
</t>
<t tx="ntallen.20120215204101.1335">Attempt to rework via select. Use sonic as example.
Need to accept commands, send telemetry synchronously and talk to serial device.
Figure out how to replace dev_read()...</t>
<t tx="ntallen.20120215204101.1336">MKS ion gauge: 972-MAN_MKSiongauge.pdf
  Default baud rate is 9600. No flow control
  Currently configured 38400/8/1/n
  
  Pressure Reading Query at 8 Hz
  Reported in mbar

  Apparently only one currently connected to AthenaII_a on /dev/ser4 addr @100

2 gauges.  We will manually preset all of the relevant gauge settings (gas
type, relay setpoint, etc), and then lock the settings down.  The only
command we envision issuing via the algo is the pressure reading query. 
We'll query at 8 Hz, and the gauges will be set to mbar units.

I attached the gauge manual for reference.  The gauges have addresses,
with 100 being the hex chamber and 101 being the ToF chamber.  The
pressure reading query can be done via the universal address, 254.

The query:
@254PR3?;FF

Each gauge will reply with something like:
@100ACK1.23E-4;FF

Generally speaking (from the manual),

The response to a query or a successful command is:
@&lt;device address&gt;ACK&lt;data&gt;;FF
The response to a message with an error is:
@&lt;device address&gt;NAK&lt;NAK code&gt;;FF

Not sure what we want to log if the gauge replies with an error.  I think
that's it for the ion gauges.

</t>
<t tx="ntallen.20120215204101.1337">Horiba STEC mass flow controllers:


The manual for the flow controllers is attached.  For these, we will issue
commands individually for both the sets and the reads.


from John:
------
This RS-485 communication protocol requires passing hex characters that 
are not representable using simple ASCII characters:

stty setup command:

stty baud=38400 bits=7 par=odd stopb=1 &lt; /dev/serX

Sample query:

query: "@ 0 1 0x02 R F S 0x03 0x6E" --&gt; response: "0x02 3 , D 0x03 0x26" 
--&gt; pc_ack:" 0x06" or pc_nak: "0x15"

query:
0 1 --&gt; address (2 characters)
0x02 --&gt; start transmission
R F S --&gt; command ('Read full scale')
0x03 --&gt; end transmission
0x6E --&gt; block check character (BCC)

response:
0x02 --&gt; start transmission
3 , D --&gt; data (Full scale value, with unit)
0x03 --&gt; end of transmission
0x26 --&gt; BCC

The BCC is derived by summing all characters after (but not including) 
0x02 through 0x03 (including 0x03) and then mod'ing this by 128
(decimal).  Remainder is then equal to BCC.  Note, if BCC is equal to a 
special character (as defined in the docs) then several additional ETX 
(end of transmission) characters need to be transmitted after BCC (see 
docs).  If the BCC character calculated by flow controller for the 
received command does not match that which was sent with the command,  the
command is ignored and NAK is is returned (0x15).  Likewise, if the  BCC
calculated by the PC does not match that transmitted by the MFC, the  PC
can respond with NAK, and the MFC will retransmit the response.
------

With regard to the BCC and conflicts with a special character, John
determined that transmitting 9 ETX characters after BCC works in all cases
so there is no need to also implement the 3 ETX approach for the @ symbol.

The flow controllers will be addressed as 01 (dilution), 02 (ion source),
and 03 (fluorine).

Units: sccm for all.


I see us wanting to do three things:

Set flow.  Command: 'A F C'

Read set point. Command: 'R F C'

Read flow rate.  Command: 'R F V'


In John's home directory on the Athena he has a few of the .hex
implemented.



Horiba STEC pressure controller:


Here we will set the control pressure with a hard-wired analog voltage,
but do the reads digitally.  We will want both the set point and pressure
reads, commands the same as above for the MFCs.

Address: 51.

Units:  mbar for both reads.

</t>
<t tx="ntallen.20120215204101.1338"></t>
<t tx="ntallen.20120215204101.1339">There is a lot of similarity between the Hercules/AthenaII/DMM32 data acquisition circuits. It might make sense to come up with a unified architecture for these.

On CIMS, we wrote a driver for DMM32 which handled individual A/D reads, D/A writes and standard SCDC/DCCC commands.

On the Triple, we replaced the DMM32 with the onboard circuits on the Hercules. Instead of writing a driver, I just included the acquisition code in the appropriate programs (A/D in collection, D/A and command stuff in command server.)

The old driver included a fair amount of inefficiency, specifically waiting for A/D channel conversion on each request. In the triple (or was it Bruker), I converted all the channels and used an interrupt to signal that the conversion was complete. Kind of depends on what the data rates are.</t>
<t tx="ntallen.20120215204101.1340">A/D Initialization
    Specify range for each channel
    See init_herc_ad() in herc_ad.c
    Writing to an A/D channel could set the gain
    Multi-write could write them all, but it's a one-time operation,
    so maybe not worth over-optimizing.
A/D Acquisition
    Read from A/D:
        If newly converted data is ready, read it into driver cache
        Report read from driver cache
        Trigger a new conversion
    Multi-read is very useful in this case
D/A
    write_da(channel, value)
    Cache d/a values in driver
    Support Multi-read

Digital I/O
    Will there be strobed commands? Probably... (though not on athena)
    These commands assume some sort of configuration file that maps cmd_num to
    command type, port and bit.
    
    herc_cmd(cmd_num, val);
    herc_strobe(cmd_num);
    
    I could write directly to ports, but it makes more sense to write to
    individual command lines. Might be reasonable to assign sequential
    command numbers, all enabled, rather than being fully configurable,
    but configurability is possible as well.
    
    Read directly from ports.</t>
<t tx="ntallen.20120220091857.1355">Posted 2/20/12:
    
    On the Ion Gauge devices, have you tested having both connected to the same RS-485 port? I'm assuming the responses will just get concatenated if a request goes out on the universal address, but it would be comforting to see it in action.
    
    I see you have the Ion Gauge configured for 38400/8/1/N. Do you think we'll stick with that for flight?
    
    What precision is required for recording these pressures? I'm trying to figure out whether I should store the data as fixed or floating point.</t>
<t tx="ntallen.20120220091857.1356">Need to R/W serial port, poll at 8 Hz
Report data to telemetry synchronously
Could terminate when collection terminates

Since no commanding is required, should be able to simply loop on:
    poll device with timeout
    blocking write to telemetry

If we need to quit more gracefully:
    loop:
        select on device, command and telemetry
        if device
            read data, save in transmit buffer
            write second query
            set fresh bits
        if command
            break
        if telemetry
            write to telemetry
            clear fresh bits
            write first query to device (needs access to device)

If I use Selector, I need three Selectees
    device
    command
    telemetry

float hex_chamber_P;
float ToF_chamber_P;
unsigned char hex_P_stale;
unsigned char ToF_P_stale;
unsigned char IG_stat; // Present, hex_P_fresh, ToF_P_fresh

unsigned char IG_stale;</t>
<t tx="ntallen.20120220091857.1357">Need command and telemetry
</t>
<t tx="ntallen.20120220091857.1358">How can I start up flight.sh stacks on two machines?
Can they be the same Experiment?
    I think so.
    
Node 2 (athenaII_a
    /home/flight/Experiment.config -&gt; /home/Exp/Experiment.config
    /home/Exp/Experiment.config
    /home/Exp/bin/X.X/runfile2
        wait indefinitely for /net/herc_a/dev/huarp/cmd/Quit
        Invokes drivers which controllers on node 1 talk to
Node 1
    /home/Exp/bin/X.X/runfile
        Starts up everything local
        No need to signal athenaII.

</t>
<t tx="ntallen.20120229211436.1363">All analog I/O configured using:
    Single-ended
    Bipolar
Range varies by channel, so needs to be configurable
</t>
<t tx="ntallen.20120229211436.1364"></t>
<t tx="ntallen.20120229211436.1365">None required at present
</t>
<t tx="ntallen.20120301085305.1369">A driver will support A/D, D/A and DIO. A separate driver will be required for each such grouping, i.e.:
    Hercules
    AthenaII
    DMM32
but I expect these to be very similar.

The driver will use the resource manager library to establish a name in the /dev/huarp/ToF hierarchy and communicate using the _IO_MSG hook to do Send/Receive/Reply full duplex communication following the pattern of subbus_2010/subbusd.

I will provide a C++ framework supporting the API and capable of packing and unpacking the message structures required.

</t>
<t tx="ntallen.20120301085305.1370">In subbus_2010, it appears I created two paths for termination:
    Send SBC_QUIT message via the standard subbus library
    Write 0 bytes to /dev/huarp/subbus
I built a custom interface type into cmdgen: %INTERFACE &lt;subbus&gt;. This specifically triggers load_subbus() (through subbus.oui) and invokes subbus_quit() at termination. I think this means I never used the second termination mechanism. However, I think the second method would work for these drivers without extending cmdgen. I think simply specifying:
    %INTERFACE &lt;AthenaII:AthenaII&gt;
will establish the connection and send the shutdown command.

Of course, from the usability standpoint, it may make sense to support a write only ASCII interface for commands (setting D/A channels, DIO bits):
    Waddr:data[,addr:data]*\n
The main upside to that is we can use if_AthenaII.Turf(); and don't require any additional library interaction.</t>
<t tx="ntallen.20120301085305.1371">Not-so-special case of Multi-Write
16-bit Address, Data
Return status:
    OK
    FAIL (Invalid Address)
Any required control structures could be built into this. e.g. reset
</t>
<t tx="ntallen.20120301085305.1372">Not-so-special case of Multi-Read
16-bit Address
Return Status
    OK
    FAIL (invalid address)
Return Data
    16-bit Word</t>
<t tx="ntallen.20120301085305.1373">List of Addresses

Return Status
    OK: All addresses valid
    FAIL: At least one address invalid
Return Data:
    Array of binary data
</t>
<t tx="ntallen.20120301085305.1374">List of Address, Data pairs

Return status:
    OK
    FAIL (Invalid Address)
Any required control structures could be built into this. e.g. reset
</t>
<t tx="ntallen.20120301085305.1375">May as well define these for the most general case: Multi-Read/Write
We can support a complex return status, but I think OK/FAIL should be just fine for starters. None of these calls should fail under normal circumstances, so failures should be considered serious problems.

Status return of 0 will mean success
Status return of 1 will mean failure

</t>
<t tx="ntallen.20120301085305.1376">Within each driver, we can provide address space as follows:
    0x1000     R First A/D Channel
    0x1001     R Second A/D Channel
    0x1000+N-1 R Last A/D Channel
    #define GAIN_MASK 0x300


    0x2000     RW First D/A Channel
    0x2001     RW Second D/A Channel
    0x2000+M-1 RW Last D/A Channel
    
    0x3000     RW First DIO Port
    0x3001     RW Second DIO Port
    ...
    
    0x4000     RW First DIO Bit (lsb of 0x3001)
    0x4001     RW Second DIO Bit ('2' bit of 0x3001)
        The bits in the 0x4000 region could be configurable ala DCCC, which is to say
        they don't have to be just bits. They could be masked words, with bit being the
        default. The configuration could be hard coded in the driver or read from a file.

The number of channels probably depends on the specific hardware. I could theoretically extend the driver to report it's configuration and other status at low addresses, but there is no scenario where we will be addressing one of these blind without knowing what we are talking to.
</t>
<t tx="ntallen.20120301085305.1377">class dsdaq {
  public:
    dsdaq(const char *path, const char *node);
    int read(unsigned short addr, unsigned short &amp;data);
    int write(unsigned short addr, unsigned short data);
    dsdaq_req *pack( int n_arg, ... );
    int send(dsdaq_req *req, unsigned short *data = NULL);
  private:
    int fd;
};

class dsdaq_req {
  public:
    dsdaq_req( unsigned short rtype, int n_arg, ... );
    int send( unsigned short *data = NULL );
  private:
    dsdaq_req_t *req;
    dsdaq *ds;
};
</t>
<t tx="ntallen.20120304143951.1387">Just do the conversions by brute force on request.
Configuring a channel and performing a conversion takes about 15 usecs. Converting 16 of them for an mread() would require 240 usecs. C'est la vie.

If all the boards supported scans with gain configurable on a channel-by-channel basis, we could do scans and lower our software overhead, but we can't. Hercules does support that, but it isn't clear that we have a lot to gain by taking advantage of that.

</t>
<t tx="ntallen.20120307100756.1389">We could use the scan mode on the Hercules, which supports pre-programmed gain settings for each channel.</t>
<t tx="ntallen.20120307100756.1390">We will not use interrupts or scan mode. AthenaII does not support scans with gain config for individual channels. The convert time is pretty small, so setting up an interrupt for individual conversions probably introduces more overhead than is called for.

A/D: 16 single-ended/8 differential inputs, 16 bit resolution
D/A: 4 12-bit 
DIO: 24 bits

Configuration via jumper block J13:
    SE/DIFF: When jumpered, 16 single-ended input channels, else 8 differential
    AD UNIPOL: When jumpered, unipolar (0-10V), else bipolar
    DA SEL: When jumpered, unipolar (0-10V), else bipolar (-10V to +10V)

For ToF:
    A/D will be configured as Single Ended Bipolar.
    D/A will bipolar, so +/- 10V: 0 =&gt; -10V 4096 =&gt; +10V.

A/D Gain settings are defined on page 67 of the AthenaII manual
    Bipolar 0 0 +/-10V
    Bipolar 0 1 +/- 5V
    Bipolar 1 0 +/- 2.5V
    Bipolar 1 1 +/- 1.25V
    Unipolar 0 0 undefined
    Unipolar 0 1 0-10V
    Unipolar 1 0 0-5V
    Unipolar 1 1 0-2.5V
</t>
<t tx="ntallen.20120325104334.1393"></t>
<t tx="ntallen.20120325104334.1394">As of 3/25/12:
    athenaII_a: 131.215.103.167
    herc_a: 131.215.103.182

There will be 3 more:
    ToF:
    triple (QNX6):
    triple (Win):
    </t>
<t tx="ntallen.20120325104334.1395"></t>
<t tx="ntallen.20120325104334.1396">Don't quit on null command
write saverun hook to retrieve log file
Add fixdisk to startup on herc_a and athenaII_a
</t>
<t tx="ntallen.20120328210636.1401">A/D: Single-ended, bipolar. Gain can be adjusted per channel, but most are +/- 10V
D/A: Bipolar +/- 10V
DIO: 4 ports out 1 port in. bit-addressed ports, plus some with strobe
    Need to add some additional logic to the 0x4000 region
    For strobed commands, I could ignore the value, and simply pulse the specified line
    That's more or less consistent with how we do it with dccc.
    Alternative would be to map those commands to separate numbers.
    Actually, referring to the requirements and the old code, I think I need to go with
    the more complex mapping scheme that does not map numbers directly to bits. I can
    again ignore the value, but reserve the right to use it for SET type commands

DIO bits 0-31 are outputs.
  Bits 0-7 are set commands
  Bit 8 is the strobe, so should be marked spare.
  Bits 9-18 are strobed commands
  Bit 19 is spare
  Bits 20-31 are set commands</t>
<t tx="ntallen.20120328210636.1402"></t>
<t tx="ntallen.20120328210636.1403">Hercules specs:
    32 16-bit single-ended A/D channels or
      16 16-bit differential A/D channels
    4 12-bit D/A
    40 bits of digital I/O

Base Address 0x240

Relevant Configuration Registers:
    Base+1: A/D &amp; D/A config:
        2: DABU D/A config. 0: bipolar 1: unipolar (default)
        1: SEDIFF A/D config. 0: single 1: diff
        0: ADBU A/D config. 0: bipolar 1: unipolar
    Base+2: A/D Low Byte
    Base+3: A/D High Byte
    Base+4: A/D Input Range control
        W: 7 LDAD 0: global 1: single
           1-0: n where gain = 2^n
        R: Status Readback
            7: A/D Busy
            6: Wait
            5: DABUSY
            4: DABU
            3: SEDIFF
            2: ADBU
            1-0: Gain
    Base+5: D/A Address
    Base+6: D/A LSB
    Base+7: D/A MSB
    Base+12: Configuration
        6: Single (which gain applies)
    Base+15:
        0: ADSTART
    Base+17-20: DIO
    Base+22: DIO Ctrl
        </t>
<t tx="ntallen.20120331125541.1405">Same basic mapping as AthenaII:
    0x1000: A/D
    0x2000: D/A
    0x3000: Byte Digital I/O
    0x4000: Bit Digital &amp; strobed commands
    
A/D:
    0x1000 - 0x1FFF (12 bits of address)
    We have 32 channels, (0x00 - 0x1F) 5 bits of channel select
    2 bits for gain select
    1 bit for ADBU (We will probably go bipolar all the way)
    1 bit for SE/DIFF (We will go SE
    #define HERC_AD_CHANNEL 0x1F
    #define HERC_AD_GAIN 0x60
    #define HERC_AD_UNIPOLAR 0x80
    #define HERC_AD_DIFFERENTIAL 0x100
    #define HERC_AD_OFFSET_MAX 0x1FF
    
    0x1000 000 BiP 1 -10    10
    0x1020 001 Bip 2  -5     5
    0x1040 010 Bip 4  -2.5   2.5
    0x1060 011 Bip 8  -1.25  1.25
    0x1080 100 Uni 1   0    10
    0x10A0 101 Uni 2   0     5
    0x10C0 110 Uni 4   0     2.5
    0x10E0 111 Uni 8   0     1.25
    
    Assign addresses from 0 to 15 (or 31)
    Use offsets as part of the type.

D/A:
    0x2000
    #define HERC_DA_SU 0x80 // simultaneous update</t>
<t tx="ntallen.20120410211453.1407">Read commands for flow set points
Pressure setpoint is set via an analog signal

Send data synchronously to TM
    3 flow controllers:
        01 dilution
        02 ion source
        03 flourine
        units sccm
    1 pressure controller
        51

R/W to RS-485 for commands and readback.

Commands to set flows
    W\d:\d+[\.\d*] (steal parser from DSDaq.cc)</t>
<t tx="ntallen.20120412210238.1409">Fluorine MFC
range: 0-3 sccm
resolution: .01 sccm

Ion Source MFC
range: 0-750 sccm
resolution: .1 sccm

Dilution MFC
range: 0-3000 sccm
resolution: 1 sccm

Pressure controller
range: 10-300 kPa (it's absolute pressure)
resolution: 0.1 kPa
</t>
<t tx="ntallen.20120412210238.1410">SerSelector

Class HoribaCmd public Selectee
    Could be derived from Cmd_Sel, but Cmd_Sel does almost nothing.
    
Class Horiba public Ser_Sel:
    Monitor serial port for incoming data
    gflag(0) for TM synch
    gflag(1) for incoming commands

If a command comes in on the command channel, it needs to be enqueued to the Ser_Sel. This could be handled through another gflag. Or I could recognize that a command is ready to be read, signal with a gflag, then read it. That doesn't solve the queueing problem, since we might get more than one command. Actually, the implementation does guarantee one command per read.

Cmd_Sel will listen on cmd channel. When command is ready, it will read one command and either signal termination or store the command and signal with gflag(1) that a command is ready.

Horiba will observe glag(1), and when appropriate, will request the command and issue the appropriate query. That means Horiba needs direct access to HoribaCmd

Ser_Sel will need to specify timeouts after queries (and possibly after responses)
</t>
<t tx="ntallen.20120415090314.1413">There are 8 data queries and then the variable command query
A query consists of the query string, a pointer to a result location, a scale factor and a status mask.
If the pointer is null, this was a 'set' command and no return value is expected.</t>
<t tx="ntallen.20130628202556.1415"></t>
<t tx="ntallen.20130628202556.1416">Manual: EZ PMI - Rev M.pdf

Driver Interfaces:
    TM: Report status, temperature, setpoint
    Cmd: Set temperature setpoint, Quit
    MODBUS: Poll for data, relay commands</t>
</tnodes>
</leo_file>
